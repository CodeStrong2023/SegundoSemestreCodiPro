PYTHON -> .py 

Definiciones.
    Expresión: Fragmento de cófigo que retorna un resultado.
    Variable: Nombre que se otorga a una expresión (siempre en minúscula)
    Variable = Expresión
    Datos: Permiten clasificar la onformación que contiene una variable
    
Tipo de datos:
    Integer: Nros enteros
    Float: Nros racionales
    Strings: Cadenas de texto
    Booleans: True o False
    Complex: Nros complejos (j)

    Para conocer el tipo de dato de una variable se puede usar la funcion:
        type()    

Comentarios:
    Líneas de texto informativas que python ignora.
        # -> Tipo renglón
        """   """ -> Tipo párrafo

Operaciones aritméticas:
    + -> Suma
    - -> Resta 
    / -> División
    * -> Multiplicación
    ** -> Potencia
    // -> División entera
    % -> Módulo

Operadores de comparación:

    == -> Igualdad
    != -> Desigualdad
    > -> Mayor
    < -> Menor
    >= -> Mayor o igual que
    <= -> Menor o igual que 

        Los operadores de comparación <, >, <= y >= sólo se aplican a int o float. 

Colecciones en Python
    Listas 
        Mutables
        Sintaxis:
            nombre = ['elemento1', 'elemento2','elemento3']
            lista = [1,2,3]
            print(len(nombre)) // cantidad de elementos 
            nombre.append(elemento4) //Agrega un elemento al final, puede ser de cualquier tipo incluso otras listas
            lista1= nombre + lista // Concatenar dos listas y crear una nueva
            lista1.extend([3,4,5]) // Agrega varios elementos a la lista
            print(nombre.index('elemento2')) // Muestra en que indice esta el elemento, si se pone un valor que no está arroja error
            print(nombre.count('elemento1')) // Es para saber cuántos elementos repetidos hay
            print(nombre.reverse()) // Imprime la lista al reves 
            nombre1 = nombre * 2 // Para que la lista se multiplique repitiendo sus elementos
            pritn(nombre.sort())// Para imprimir los elementos ordenados de manera ascendente
            print(nombre.sort(reverse=True)) // Imprime los elementos ordenados de manera descendente
        Pilas:
            Siempre se trabaja con el último elemento como si se tratara de una lista apilada.
            nombre.append['elemento4'] // Agrego elementos por el final
            nombre.pop() // Elimina el último elemento de la pila 
            elementoBorrado = nombre.pop() // Elimina la variable de la pila y la asigna a una nueva variable
        Colas: 
            Estructuras de datos de tipo fifo (first input/first output).
            nombre.append('Elemento4') // Se agrega un elemento al final de la cola 
            nombre.pop(0) // Se retira el primer elemento de la cola 


    Tuplas 
        Inmutables. Pueden tener diferentes tipos de elementos. No admite modificaciones de sus elementos, ni agregar ni quitar elementos.
        Podemos transformar tuplas en listas y listas en tuplas.
        Sintaxis:
            tupla = (4, 'Elemento2', 'Elemento3')
    Set 
        Son mutables pero no admite repeticiones, no contiene indice y su orden es aleatorio. También se lo conoce como conjuntos.
        Sintaxis:
            nombre = {'elemento1', 'elemento2', 'elemento3'}
            nombre = set('elemento1', 'elemento2', 'elemento3')

            print(len(nombre)) // cantidad de elementos 
            print("elemento1" in nombre) // respuesta booleana a si el elemento está en el set 
            nombre.add("elemento4") // agregar elemento4 al set, no se puede agregar duplicado ni multiples elementos con esta fn
            nombre.remove("elemento1") // Elimina el elemento1, puede arrojar error si el dato no existe
            nombre.discard("elemento1") // Elimina el elemento1, no arroja error si el dato no existe
            nombre.clear() // Limpia el set

            Operaciones conconjuntos:

            conjunto3= conjunto1 | conjunto2 // Conjunto de los dos elementos. Si hay elementos repetidos, usa solo uno 
                print(conjunto1.issubjet(conjunto3)) // Imprime un booleano si un conjunto es subconjunto de otro
                print(conjunto3.issuperset(conjunto1)) // Imprime un booleano si el conjunto3 contiene al conjunto1
                print(conjunto1.isdijoint(conjunto2)) // Imprime un booleano según si tienen elementos en común o no
            conjunto3= conjunto1 & conjunto2 // Conjunto de elementos que tienene en común
            conjunto3= conjunto1 - conjunto2 // Conjunto con los elementos del conjunto2 que no estan en el conjunto1
            conjunto3= conjunto2 - conjunto1 // Conjunto con los elementos del conjunto1 que no estan en el conjunto2
            conjunto3= conjunto1 ^ conjunto2 // Conjunto con elementos del conjunto1 y conjunto2 pero que no estan en ambos
            conjunto = frozenset // Hace que el conjunto sea totalmente inmutable, no se puede agregar ni quitar elementos
            

    Disccionarios
        Estan compuestos por dos elementos; el par clave (llave, key), valor (value). Los elementos no poseen indices, se accede a los valores a través de
        las claves.
        Sintaxis:
            nombre = {
                'Clave1':'valor1',
                'Clave2:'Valor2',
                'Clave2':'Valor3'
            }

             print(len(nombre)) // cantidad de elementos 
             print(nombre['Clave1']) //Accede al valor desde la llave del elemento en el diccionario, la clave es case-sensitive.
             print(diccionario.get('Clave2')) // Es otra manera de recuperar valores a traves de claves.
             nombre['Clave1']='Value1' // Cambia el valor asociado a la clave.
             print('Clave1' in nombre) // Devuelve un booleano si el elemento está o no en el diccionario
             nombre['Clave4'] = 'Valor4' // Agrega un elemento al diccionario
             nombre.pop('Clave2') // Elimina el par clave valor.
             nombre.clear() // Elimina todos los elementos del diccionario.
             del nombre // Elimina el diccionario
             del (nombre('Clave1')) // Para eliminar un elemento del diccionario con su clave 
             nombre = {clave1 : {subclave1:valor1}} // Los diccionarios pueden contener subdiccionarios
             nombre = {clave1 : {subclave1:valor1, clave2 : [dato1, dato2]}} // Los diccionarios pueden tener diferentes tipos de datos
             Recorrer el diccionario mostrando las claves con un bucle for:
                for termino in diccionario:
                    print(termino)

            Funcion para recorrer un diccionari:
                for termino, valor in diccionario.items():
                    print(termino,valor)        

            Otra manera de acceder al diccionario mostrando solo las claves:
                for termino in diciionario.keys():
                    print(termino)

            Otra manera de acceder al diccionario mostrando solo valores:
                for valor in diccionario.value():
                    print(valor)        

Funciones
    Bloque de código que se puede llamar n cantidad de veces
    Sintaxis:
        def miFuncion():
            *Aqué debajo se coloca identado lo que queremos que la función haga.

Desempaquetado de listas y disccionarios:
    Definimos una función show:
        def show(nombre, apellido)

    Definimo suna lista y un diccionario:
        persona = ["Emilia, "Bazán"]
        persona2 = {"apellido" : "Betancud"; "nombre": "Ariel"}
        

    Mostramos los elementos de la lista llamando a la función, colocando el nombre de la lista precedido de un asterisco:
    show(*persona)

    Mostramos los elementos del diccionario llamando a la función, colocando el nombre de la lista precedido de dos asteriscos:
    show(**persona2)

Lista de compresión
    Sirve para usar elementos utiles de listas, diccionarios o tuplas sin modificarlas.

        ej con lista:

        nombres = ["Paolo","Rodrigo","Lupe", "Pepe"]
        alongP = [p for p in nombres if p[0]=='p'] # Esto devuelve una nueva lista dónde se muestren los nombres con P.
        pint[alongP]
        
        ej con diccionario:

        botellaC =  [{"name" : "Quilmes", "pais": "Argentina"}, 
                    {"name" : "Corona", "pais": "Mx"},
                    {"name" : "Stella Artois", "pais": "Bélgica"}]

        arg = [b for b in botellaC if b[pais]=="Argentina"] 

        print[arg]           

Paso de argumentos

    mi_funcion2(name, lastName);
    print(Saludos a todos los que nos ven a través del canal de youtube)
    printo(f'Nombre: {name}, apellido: {lastName}')

    llamamos la funcion y pasamos los argumentos:
    mi_funcion2('Emilia','Bazán')
    mi_funcion2('Pedro','Perez')

Palabra return:
    Creamos una función para sumar:
        def sumar(a,b):
            return a + b
        resultado = sumar(78, 82)    
        print(f' El resultado de las uma es:{resultado}')

        Se puede llamar a la función de la siguiente manera:
        print{f'El resltado de la suma es:{sumar{22,12}}}

Valores por default de argumentos:
    Se otorga a las variables un valor por default para que no salga un error si no se asignan valores a las variables.
    
    definimos otra funcion sumar
        def sumar2(a = 0,b = 0):
            return a + b
        resultasdo = sumar()    
            print(f' El resultado de las uma es:{resultado}')
            print{f'El resltado de la suma es:{sumar{22,12}}}

Argumentos variables en una función:
    se usa cuando se desconoce la cantidad de argumentos que tendrá una lista que pueden variar, se añaden a la funcion 
    def listarNombres(*nombres): # Normalmente se utiliza *args
        for nombre in nombres:
            print(nombre)
listaNombres('Lucas', 'María','Jose','Pablo')
listaNombres('Pedro','Pablo', 'Mario')